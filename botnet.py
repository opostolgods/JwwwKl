import sqlite3
import telethon
from telethon import TelegramClient, events, sync, functions
from telethon.errors import SessionPasswordNeededError, FloodWaitError
from telethon.tl.types import InputReportReasonSpam, InputReportReasonFake, InputReportReasonViolence, InputReportReasonChildAbuse, InputReportReasonOther
from telethon.tl.functions.messages import ReportSpamRequest
import asyncio
import telebot
from telebot import types
from telethon import types as telethon_types
import time
import os
import shutil
import random
from datetime import datetime, timedelta
from pyCryptoPayAPI import pyCryptoPayAPI
import config
from telethon.tl.types import PeerUser

while True:
    try:
        reasons = [
            InputReportReasonSpam(),
            InputReportReasonFake(),
            InputReportReasonViolence(),
            InputReportReasonChildAbuse(),
            InputReportReasonOther()
        ]

        API = "7253894752:AAF50Bxqn7l9BbVFzem2QECcjmNmBouW88A"

        bot = telebot.TeleBot(config.TOKEN)
        bot_name = config.bot_name
        bot_logs = config.bot_logs
        bot_channel_link = config.bot_channel_link
        bot_admin = config.bot_admin
        bot_documentation = config.bot_documentation
        bot_reviews = config.bot_reviews
        bot_works = config.bot_works
        crypto = pyCryptoPayAPI(api_token=config.CRYPTO)
        session_folder = 'sessions'
        sessions = [f.replace('.session', '') for f in os.listdir(session_folder) if f.endswith('.session')]
        last_used = {}

        subscribe_1_day = config.subscribe_1_day
        subscribe_7_days = config.subscribe_7_days
        subscribe_14_days = config.subscribe_14_days
        subscribe_30_days = config.subscribe_30_days
        subscribe_365_days = config.subscribe_365_days
        subscribe_infinity_days = config.subscribe_infinity_days

        menu = types.InlineKeyboardMarkup(row_width=2)
        profile = types.InlineKeyboardButton("üë§ –ü—Ä–æ—Ñ–∏–ª—å", callback_data='profile')
        doc = types.InlineKeyboardButton("‚≠êÔ∏è –ö–∞–Ω–∞–ª", url=f'{bot_documentation}')
        shop = types.InlineKeyboardButton("üõí –ü–æ–¥–ø–∏—Å–∫–∏", callback_data='shop')
        snoser = types.InlineKeyboardButton("üåê –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –ø–∏—Ü—É", callback_data='snoser')
        menu.add(profile)
        menu.add(doc, shop)
        menu.add(snoser)

        back_markup = types.InlineKeyboardMarkup(row_width=2)
        back = types.InlineKeyboardButton("üîô –ù–∞–∑–∞–¥", callback_data='back')
        back_markup.add(back)

        channel_markup = types.InlineKeyboardMarkup(row_width=2)
        channel = types.InlineKeyboardButton(f"‚ö°Ô∏è {bot_name} - –∫–∞–Ω–∞–ª", url=f'{bot_channel_link}')
        channel_markup.add(channel)

        admin_markup = types.InlineKeyboardMarkup(row_width=2)
        add_subsribe = types.InlineKeyboardButton("–í—ã–¥–∞—Ç—å –ø–æ–¥–ø–∏—Å–∫—É", callback_data='add_subsribe')
        clear_subscribe = types.InlineKeyboardButton("–ó–∞–±—Ä–∞—Ç—å –ø–æ–¥–ø–∏—Å–∫—É", callback_data='clear_subscribe')
        send_all = types.InlineKeyboardButton("–†–∞—Å—Å—ã–ª–∫–∞", callback_data='send_all')
        admin_markup.add(add_subsribe, clear_subscribe)
        admin_markup.add(send_all)

        shop_markup = types.InlineKeyboardMarkup(row_width=2)
        sub_1 = types.InlineKeyboardButton(f"üîπ 1 –¥–µ–Ω—å - {subscribe_1_day}$", callback_data='sub_1')
        sub_2 = types.InlineKeyboardButton(f"üîπ 7 –¥–Ω–µ–π - {subscribe_7_days}$", callback_data='sub_2')
        sub_4 = types.InlineKeyboardButton(f"üîπ 30 –¥–Ω–µ–π - {subscribe_30_days}$", callback_data='sub_4')
        sub_6 = types.InlineKeyboardButton(f"üîπ –Ω–∞–≤—Å–µ–≥–¥–∞ - {subscribe_infinity_days}$", callback_data='sub_6')
        shop_markup.add(sub_1, sub_2)
        shop_markup.add(sub_4, sub_6)
        shop_markup.add(back)

        def check_user_in_db(user_id):
            conn = sqlite3.connect('users.db')
            cursor = conn.cursor()
            cursor.execute('SELECT user_id FROM users WHERE user_id = ?', (user_id,))
            result = cursor.fetchone()
            conn.close()
            return result is not None

        def extract_username_and_message_id(message_url):
            try:
                path = message_url[len('https://t.me/'):].split('/')
                print(path)
                if len(path) == 2:
                    chat_username = path[0]
                    message_id = int(path[1])
                    return chat_username, message_id
                else:
                    raise ValueError("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç URL")
            except Exception as e:
                print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–∑–±–æ—Ä–µ URL: {e}")
                raise ValueError("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç URL")

        async def main(chat_username, message_id, user):
            connect = sqlite3.connect('users.db')
            cursor = connect.cursor()
            valid = 0
            ne_valid = 0
            flood = 0
            reports = 0
            for session in sessions:
                api_id, api_hash = "20401021", "7fa6c7f62816334c230cebf77c565c3d"
                random_reason = random.choice(reasons)
                try:
                    session_file = os.path.join("sessions", session + ".session")
                    session_path = os.path.join("sessions", session)
                    
                    if not os.path.exists(session_file):
                        print(f"–°–µ—Å—Å–∏—è {session} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
                        ne_valid += 1
                        continue
                        
                    client = TelegramClient(
                        session_path,
                        int(api_id),
                        api_hash,
                        system_version='4.16.30-vxCUSTOM',
                        sequential_updates=True
                    )

                    try:
                        await client.connect()
                        if not await client.is_user_authorized():
                            print(f"–°–µ—Å—Å–∏—è {session} –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–∞")
                            ne_valid += 1
                            await client.disconnect()
                            continue
                            
                        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —á–∞—Ç–µ
                        chat = await client.get_entity(chat_username)
                        
                        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∂–∞–ª–æ–±—É, –∏—Å–ø–æ–ª—å–∑—É—è ReportSpam
                        await client(functions.messages.ReportSpamRequest(
                            peer=chat
                        ))
                        reports += 1
                        await client.disconnect()
                    except FloodWaitError as e:
                        flood = flood + 1
                        print(f'Flood wait error ({session}): {e}')
                        await client.disconnect()
                    except Exception as e:
                        if "chat not found" in str(e):
                            bot.send_message(user, "üö´ *–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è!*", parse_mode="Markdown", reply_markup=back_markup)
                            await client.disconnect()
                            return
                        elif "object has no attribute 'from_id'" in str(e):
                            bot.send_message(user, "üö´ *–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è!*", parse_mode="Markdown", reply_markup=back_markup)
                            await client.disconnect()
                            return
                        elif "database is locked" in str(e):
                            connect.close()
                            continue
                        else:
                            ne_valid += 1
                            print(f'–û—à–∏–±–∫–∞ ({session}): {e}')
                            await client.disconnect()
                            continue
                except Exception as e:
                    print(f'–û—à–∏–±–∫–∞ ({session}): {e}')
                    continue

            user_markup = types.InlineKeyboardMarkup(row_width=2)
            user_profile = types.InlineKeyboardButton(f"{user}", url=f'tg://openmessage?user_id={user}')
            user_markup.add(user_profile)
            bot.send_message(bot_logs, f"‚ö°Ô∏è *–ü—Ä–æ–∏–∑–æ—à–µ–ª –∑–∞–ø—É—Å–∫ –±–æ—Ç–∞:*\n\n*ID:* `{user}`\n*–°—Å—ã–ª–∫–∞: https://t.me/{chat_username}/{message_id}*\n\nüîî *–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–µ—Å—Å–∏—è—Ö:*\n‚ö°Ô∏è –í–∞–ª–∏–¥–Ω—ã–µ: *{reports}*\n‚ö°Ô∏è *–ù–µ –≤–∞–ª–∏–¥–Ω—ã–µ: {ne_valid}*\n‚ö°Ô∏è *FloodError: {flood}*", parse_mode="Markdown", disable_web_page_preview=True, reply_markup=user_markup)
            bot.send_message(user, f"‚ö°Ô∏è *–ñ–∞–ª–æ–±—ã —É—Å–ø–µ—à–Ω–æ –ø–æ–¥–∞–Ω—ã!*  \n\nüü¢ *–í–∞–ª–∏–¥:* `{reports}`  \nüî¥ *–ù–µ –≤–∞–ª–∏–¥:* `{ne_valid}`", parse_mode="Markdown", reply_markup=back_markup)
            connect.close()

        @bot.message_handler(commands=['start'])
        def welcome(message):
            connect = sqlite3.connect("users.db")
            cursor = connect.cursor()
            cursor.execute("""CREATE TABLE IF NOT EXISTS users(
                user_id BIGINT,
                subscribe DATETIME
            )""")
            people_id = message.chat.id
            cursor.execute("SELECT user_id FROM users WHERE user_id = ?", (people_id,))
            data = cursor.fetchone()
            if data is None:
                cursor.execute("INSERT INTO users VALUES(?, ?);", (people_id, "1999-01-01 20:00:00"))
                connect.commit()
                bot.send_message(message.chat.id, "üëã *–ü—Ä–∏–≤–µ—Ç!*", reply_markup=channel_markup, parse_mode="Markdown")
            bot.send_message(message.chat.id, f'üçï *{bot_name}* ‚Äî _–±–æ—Ç –¥–ª—è –±—ã—Å—Ç—Ä–æ–π –¥–æ—Å—Ç–∞–≤–∫–∏ –ø–∏—Ü—Ü—ã._\n\n‚ö°Ô∏è *–ê–¥–º–∏–Ω: {bot_admin}*\n‚≠êÔ∏è *–û—Ç–∑—ã–≤—ã:* [–¢–´–ö]({bot_reviews})\nüî• *–†–∞–±–æ—Ç—ã:* [–¢–´–ö]({bot_works})', parse_mode="Markdown", reply_markup=menu)
            connect.close()

        @bot.callback_query_handler(lambda c: c.data and c.data.startswith('sub_'))
        def handle_subscription(callback_query: types.CallbackQuery):
            try:
                user_id = callback_query.from_user.id
                user_first_name = callback_query.from_user.first_name 
                if not check_user_in_db(user_id):
                    bot.send_message(user_id, "*‚ùóÔ∏è –í—ã –±–ª–æ–∫–∏—Ä–æ–≤–∞–ª–∏ –±–æ—Ç–∞! –ü—Ä–æ–ø–∏—à–∏—Ç–µ /start*", parse_mode="Markdown")

                subscription_type = callback_query.data.split('_')[1]

                if subscription_type == "1":
                    invoice = crypto.create_invoice(asset='USDT', amount=subscribe_1_day)
                    sub_days = "1"
                    amount = subscribe_1_day
                if subscription_type == "2":
                    invoice = crypto.create_invoice(asset='USDT', amount=subscribe_7_days)
                    sub_days = "7"
                    amount = subscribe_7_days
                if subscription_type == "3":
                    invoice = crypto.create_invoice(asset='USDT', amount=subscribe_14_days)
                    sub_days = "14"
                    amount = subscribe_14_days
                if subscription_type == "4":
                    invoice = crypto.create_invoice(asset='USDT', amount=subscribe_30_days)
                    sub_days = "30"
                    amount = subscribe_30_days
                if subscription_type == "5":
                    invoice = crypto.create_invoice(asset='USDT', amount=subscribe_365_days)
                    sub_days = "365"
                    amount = 35
                if subscription_type == "6":
                    invoice = crypto.create_invoice(asset='USDT', amount=subscribe_infinity_days)
                    sub_days = "3500"
                    amount = subscribe_infinity_days

            
                pay_url = invoice['pay_url']
                invoice_id = invoice['invoice_id']
                pay_check = types.InlineKeyboardMarkup(row_width=2)
                pay_url = types.InlineKeyboardButton("üí∏ –û–ø–ª–∞—Ç–∏—Ç—å –ø–∏—Ü—Ü—É", url=pay_url)
                check = types.InlineKeyboardButton("üîç –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–ª–∞—Ç–µ–∂", callback_data=f'check_status_{invoice_id}_{subscription_type}_{sub_days}')
                pay_check.add(pay_url, check)
                pay_check.add(back)
                bot.edit_message_text(chat_id=callback_query.message.chat.id, message_id=callback_query.message.message_id,
                    text=f'‚≠êÔ∏è *–û–ø–ª–∞—Ç–∞ –ø–æ–¥–ø–∏—Å–∫–∏ {bot_name}* ‚≠êÔ∏è\n\nüõí*–ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ {sub_days} –¥–Ω–µ–π*\nüí≥ *–¶–µ–Ω–∞:* `{amount}$`\n\n‚ú® *–°–ø–∞—Å–∏–±–æ –∑–∞ –ø–æ–∫—É–ø–∫—É!*',
                    parse_mode="Markdown", reply_markup=pay_check)
            except:
                pass

        @bot.callback_query_handler(lambda c: c.data and c.data.startswith('check_status_'))
        def check_status_callback(callback_query: types.CallbackQuery):
            try:
                user_id = callback_query.from_user.id
                if not check_user_in_db(user_id):
                    bot.send_message(user_id, "*‚ùóÔ∏è –í—ã –±–ª–æ–∫–∏—Ä–æ–≤–∞–ª–∏ –±–æ—Ç–∞! –ü—Ä–æ–ø–∏—à–∏—Ç–µ /start*", parse_mode="Markdown")
                else:
                    parts = callback_query.data.split('_')
                    if len(parts) < 4:
                        callback_query.answer("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.")
                        return
                    invoice_id = parts[2]
                    sub_days = parts[4]
                    check_status(callback_query, invoice_id, sub_days)
            except:
                pass

        def check_status(callback_query: types.CallbackQuery, invoice_id: str, sub_days):
            try:
                user_id = callback_query.from_user.id
                if not check_user_in_db(user_id):
                    bot.send_message(user_id, "*‚ùóÔ∏è –í—ã –±–ª–æ–∫–∏—Ä–æ–≤–∞–ª–∏ –±–æ—Ç–∞! –ü—Ä–æ–ø–∏—à–∏—Ç–µ /start*", parse_mode="Markdown")
                else:
                    ID = callback_query.from_user.id
                    connect = sqlite3.connect('users.db')
                    cursor = connect.cursor()
                    subscribe_str = cursor.execute("SELECT subscribe FROM users WHERE user_id = ?", (ID,)).fetchone()
                    if subscribe_str is None:
                        bot.send_message(callback_query.message.chat.id, "‚ùå *–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.*", parse_mode="Markdown")
                        return
                    subscribe_str = subscribe_str[0]
                    subsribe = datetime.strptime(subscribe_str, "%Y-%m-%d %H:%M:%S")
                    old_invoice = crypto.get_invoices(invoice_ids=invoice_id)
                    status_old_invoice = old_invoice['items'][0]['status']
                    subscription_type = old_invoice['items'][0]['amount']
                    if status_old_invoice == "paid":
                        bot.edit_message_text(chat_id=callback_query.message.chat.id, message_id=callback_query.message.message_id,
                            text=f'‚≠êÔ∏è *–û–ø–ª–∞—á–µ–Ω!*',
                            parse_mode="Markdown", reply_markup=back_markup)
                        bot.send_message(callback_query.message.chat.id, "‚ú® *–û–ø–ª–∞—Ç–∞ –ø–æ–ª—É—á–µ–Ω–∞!*", parse_mode="Markdown")
                        try:
                            days = int(sub_days)
                            new_date = (datetime.now() + timedelta(days=days)).strftime("%Y-%m-%d %H:%M:%S")
                            cursor.execute("UPDATE users SET subscribe = ? WHERE user_id = ?", (new_date, ID))
                            connect.commit()
                            # –ö–ª–∞–≤–∞
                            subscribe_markup = types.InlineKeyboardMarkup(row_width=1)
                            user_button = types.InlineKeyboardButton(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {ID}", url=f'tg://openmessage?user_id={ID}')
                            subscribe_markup.add(user_button)
                            bot.send_message(bot_logs, f'‚ö°Ô∏è *–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å* `{ID}` *–æ–ø–ª–∞—Ç–∏–ª –ø–æ–¥–ø–∏—Å–∫—É (—Ç–µ–ø–µ—Ä—å –¥–µ–π—Å—Ç–≤—É–µ—Ç –¥–æ* `{new_date}`*)*', parse_mode="Markdown", reply_markup=subscribe_markup)
                            connect.close()
                        except Exception as e:
                            connect.close()
                    else:
                        bot.send_message(callback_query.message.chat.id, "üö´ *–û–ø–ª–∞—Ç–∞ –Ω–µ –ø–æ–ª—É—á–µ–Ω–∞!*", parse_mode="Markdown")
                        connect.close()
            except:
                pass

        @bot.callback_query_handler(func=lambda call: True)
        def callback_inline(call):
            try:
                user_id = call.from_user.id
                if not check_user_in_db(user_id):
                    bot.send_message(user_id, "*‚ùóÔ∏è –í—ã –±–ª–æ–∫–∏—Ä–æ–≤–∞–ª–∏ –±–æ—Ç–∞! –ü—Ä–æ–ø–∏—à–∏—Ç–µ /start*", parse_mode="Markdown")
                else:
                    connect = sqlite3.connect('users.db')
                    cursor = connect.cursor()
                    user_id = call.from_user.id
                    subscribe_str = cursor.execute("SELECT subscribe FROM users WHERE user_id = ?", (user_id,)).fetchone()[0]
                    subsribe = datetime.strptime(subscribe_str, "%Y-%m-%d %H:%M:%S")
                    if call.message:
                        if call.data == 'snoser':
                            if subsribe < datetime.now():
                                bot.send_message(call.message.chat.id, '‚ö°Ô∏è *–í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ –∏—Å—Ç–µ–∫–ª–∞!* \n\nüö´ *–î–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –¥–æ—Å—Ç–∞–≤–∫–∏ –ø–∏—Ü—Ü—ã –∫—É–ø–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É.*', parse_mode="Markdown")
                            else:
                                if user_id in last_used and (datetime.now() - last_used[user_id]) < timedelta(minutes=5):
                                    remaining_time = timedelta(minutes=5) - (datetime.now() - last_used[user_id])
                                    bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.message_id,
                                                  text=f'üö´ *–ñ–¥–∏—Ç–µ {remaining_time.seconds} —Å–µ–∫—É–Ω–¥ –¥–æ —Å–ª–µ–¥—É—é—â–µ–π –æ—Ç–ø—Ä–∞–≤–∫–∏ –∂–∞–ª–æ–±!*',
                                                  parse_mode="Markdown", reply_markup=back_markup)
                                    return
                                last_used[user_id] = datetime.now()
                                x = bot.send_message(call.message.chat.id, f'‚ö°Ô∏è *–í–≤–µ–¥–∏—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ –Ω–∞—Ä—É—à–µ–Ω–∏–µ:*', parse_mode="Markdown")
                                bot.register_next_step_handler(x, BotNetStep1)
                        elif call.data == 'back':
                            bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.message_id,
                                text=f'‚ô®Ô∏è *{bot_name}* ‚Äî _–±–æ—Ç –¥–ª—è –º–∞—Å—Å–æ–≤–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏ –∂–∞–ª–æ–±._\n\n‚ú® *–ê–¥–º–∏–Ω: {bot_admin}*\n‚ú® *–†–∞–±–æ—Ç—ã:* [Works]({bot_works})\n‚ú® *–û—Ç–∑—ã–≤—ã:* [Reviews]({bot_reviews})',
                                parse_mode="Markdown", reply_markup=menu)
                        elif call.data == 'profile':
                            bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.message_id,
                                text=f'üë§ *–í–∞—à –ø—Ä–æ—Ñ–∏–ª—å* \n\nüÜî *ID:* `{user_id}`\nüïê *–¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è:* `{datetime.now().strftime("%Y-%m-%d %H:%M:%S")}`\nüí∞ *–ü–æ–¥–ø–∏—Å–∫–∞ –¥–æ:* `{subsribe}`\n\nüîê _–ù–µ –∑–∞–±—É–¥—å—Ç–µ –≤–æ–≤—Ä–µ–º—è –æ–±–Ω–æ–≤–∏—Ç—å —Å–≤–æ—é –ø–æ–¥–ø–∏—Å–∫—É!_',
                                parse_mode="Markdown", reply_markup=back_markup)
                        elif call.data == 'shop':
                            bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.message_id, text=(f"‚ö°Ô∏è *{bot_name} Price List* ‚ö°Ô∏è\n\nüîπ *1 –¥e–Ω—å* ‚Äî `{subscribe_1_day}$`\nüîπ *7 –¥–Ω–µ–π* ‚Äî `{subscribe_7_days}$`\nüîπ *30 –¥–Ω–µ–π* ‚Äî `{subscribe_30_days}$`\nüîπ *–ù–∞–≤—Å–µ–≥–¥–∞* ‚Äî `{subscribe_infinity_days}$`\n\nüíº *–î–ª—è –ø–æ–∫—É–ø–∫–∏ –∑–∞ —Ä—É–±–ª–∏: {bot_admin}*\n\n‚ö°Ô∏è *–†–∞–±–æ—Ç–∞–µ–º –±—ã—Å—Ç—Ä–æ!*"), parse_mode="Markdown", reply_markup=shop_markup, disable_web_page_preview = True)
                        elif call.data == 'add_subsribe':
                            msg = bot.send_message(call.message.chat.id, '*‚ö°Ô∏è  ADD SUBSCRIBE  ‚ö°Ô∏è*\n\n*–í–≤–µ–¥–∏—Ç–µ ID:*', parse_mode="Markdown")
                            bot.register_next_step_handler(msg, add_subsribe1) 
                        elif call.data == 'clear_subscribe':
                            msg = bot.send_message(call.message.chat.id, '*‚ö°Ô∏è  CLEAR SUBSCRIBE  ‚ö°Ô∏è*\n\n*–í–≤–µ–¥–∏—Ç–µ ID:*', parse_mode="Markdown")
                            bot.register_next_step_handler(msg, clear_subscribe)
                        elif call.data == 'send_all':
                            msg = bot.send_message(call.message.chat.id, '*‚ö°Ô∏è  SEND ALL  ‚ö°Ô∏è*\n\n*–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç (–±–µ–∑ –∫–∞—Ä—Ç–∏–Ω–æ–∫, —ç–º–æ–¥–∑–∏ —Ç–≥ –ø—Ä–µ–º–∏—É–º):*', parse_mode="Markdown")
                            bot.register_next_step_handler(msg, sendall1)
            except:
                pass

        @bot.message_handler(commands=['admin'])
        def admin(message):
            if message.chat.id in config.ADMINS:
                bot.send_message(message.chat.id, "‚ö°Ô∏è *ADMIN PANEL* ‚ö°Ô∏è",reply_markup=admin_markup, parse_mode="Markdown")
            else:
                bot.send_message(message.chat.id, "‚ö°Ô∏è *ADMIN PANEL* ‚ö°Ô∏è\n\n_–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤!_", parse_mode="Markdown")

        def BotNetStep1(message):
            message_url = message.text
            user = message.from_user.id
            try:
                chat_username, message_id = extract_username_and_message_id(message_url)
                if chat_username and message_id:
                    bot.send_message(message.chat.id, '‚ö°Ô∏è *–∞—Ç–∞–∫–∞ –Ω–∞—á–∞–ª–∞—Å—å!\n\n–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–∂–∏–¥–∞–π—Ç–µ.*', parse_mode="Markdown")
                    asyncio.run(main(chat_username, message_id, user))
                else:
                    bot.send_message(message.chat.id, '‚ö°Ô∏è *–ù–µ–≤–µ—Ä–Ω–∞—è —Å—Å—ã–ª–∫–∞! –ù—É–∂–Ω–∞ —Å—Å—ã–ª–∫–∞ –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ (https://t.me/XXX/YYY)!*', parse_mode="Markdown")
            except ValueError as e:
                print(f"Error parsing URL: {e}")
                bot.send_message(message.chat.id, '‚ö°Ô∏è *–ù–µ–≤–µ—Ä–Ω–∞—è —Å—Å—ã–ª–∫–∞! –ù—É–∂–Ω–∞ —Å—Å—ã–ª–∫–∞ –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ (https://t.me/XXX/YYY)!*', parse_mode="Markdown")
            except Exception as e:
                print(f"Unexpected error: {e}")
                bot.send_message(message.chat.id, '‚ö°Ô∏è *–æ—Ç–ø—Ä–∞–≤–∫–∞ –∂–∞–ª–æ–± –µ—â–µ –∏–¥–µ—Ç.*', parse_mode="Markdown")

        def add_subsribe1(message):
            try:
                ID = int(message.text)
                msg2 = bot.send_message(message.chat.id, '*‚úû  ADD SUBSCRIBE  ‚úû*\n\n*–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π:*', parse_mode="Markdown")
                bot.register_next_step_handler(msg2, add_subsribe2, ID)
            except:
                bot.send_message(f'{ID}', f'‚ö°Ô∏è *–í—ã–¥–∞–Ω–æ!*', parse_mode="Markdown", reply_markup=back_markup)

        def add_subsribe2(message, ID):
            connect = sqlite3.connect('users.db')
            cursor = connect.cursor()
            user_data = cursor.execute("SELECT subscribe FROM users WHERE user_id = ?", (ID,)).fetchone()
            if user_data is None:
                bot.send_message(message.chat.id, f'‚ö°Ô∏è *–û—à–∏–±–∫–∞!* –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å ID `{ID}` –Ω–µ –Ω–∞–π–¥–µ–Ω.', parse_mode="Markdown", reply_markup=back_markup)
                return
            subscribe_str = cursor.execute("SELECT subscribe FROM users WHERE user_id = ?", (ID,)).fetchone()[0]
            subsribe = datetime.strptime(subscribe_str, "%Y-%m-%d %H:%M:%S")
            try:
                days = int(message.text)
                new_date = (datetime.now() + timedelta(days=days)).strftime("%Y-%m-%d %H:%M:%S")
                cursor.execute("UPDATE users SET subscribe = ? WHERE user_id = ?", (new_date, ID))
                connect.commit()
                bot.send_message(f'{ID}', f'‚ö°Ô∏è *–í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞!: –¥–µ–π—Å—Ç–≤—É–µ—Ç –¥–æ* `{new_date}`.', parse_mode="Markdown")
                bot.send_message(message.chat.id, f'‚ö°Ô∏è *–í—ã –æ–±–Ω–æ–≤–∏–ª–∏ –ø–æ–¥–ø–∏—Å–∫—É* *(—Ç–µ–ø–µ—Ä—å –¥–µ–π—Å—Ç–≤—É–µ—Ç –¥–æ* `{new_date}`*) –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é:* `{ID}`', parse_mode="Markdown", reply_markup=back_markup)
                #–ö–ª–∞–≤–∞
                subscribe_markup = types.InlineKeyboardMarkup(row_width=1)
                admin_id_button = types.InlineKeyboardButton(f"–ê–¥–º–∏–Ω: {message.chat.id}", url=f'tg://openmessage?user_id={message.chat.id}')
                user_button = types.InlineKeyboardButton(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {ID}", url=f'tg://openmessage?user_id={ID}')
                subscribe_markup.add(admin_id_button, user_button)
                bot.send_message(bot_logs, f'‚ö°Ô∏è *–ê–¥–º–∏–Ω* `{message.chat.id}`*, –æ–±–Ω–æ–≤–∏–ª –ø–æ–¥–ø–∏—Å–∫—É (—Ç–µ–ø–µ—Ä—å –¥–µ–π—Å—Ç–≤—É–µ—Ç –¥–æ* `{new_date}`*) –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é* `{ID}`', parse_mode="Markdown", reply_markup=subscribe_markup)
                connect.close()
            except Exception as e:
                bot.send_message(message.chat.id, f'‚ö°Ô∏è *–û—à–∏–±–∫–∞!*', parse_mode="Markdown", reply_markup=back_markup)
                connect.close()

        def clear_subscribe(message):
            try:
                ID = int(message.text)
                new_date = "1999-01-01 20:00:00"
                connect = sqlite3.connect('users.db')
                cursor = connect.cursor()
                user_data = cursor.execute("SELECT subscribe FROM users WHERE user_id = ?", (ID,)).fetchone()
                if user_data is None:
                    bot.send_message(message.chat.id, f'‚ö°Ô∏è *–û—à–∏–±–∫–∞!* –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å ID `{ID}` –Ω–µ –Ω–∞–π–¥–µ–Ω.', parse_mode="Markdown", reply_markup=back_markup)
                    connect.close()
                    return
                subscribe_str = cursor.execute("SELECT subscribe FROM users WHERE user_id = ?", (ID,)).fetchone()[0]
                subsribe = datetime.strptime(subscribe_str, "%Y-%m-%d %H:%M:%S")
                cursor.execute("UPDATE users SET subscribe = ? WHERE user_id = ?", (new_date, ID))
                connect.commit()
                bot.send_message(f'{ID}', f'‚ö°Ô∏è *–í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ –∞–Ω–Ω—É–ª–∏—Ä–æ–≤–∞–Ω–∞!*', parse_mode="Markdown")
                bot.send_message(message.chat.id, f'‚ö°Ô∏è *–í—ã –∞–Ω–Ω—É–ª–∏—Ä–æ–≤–∞–ª–∏ –ø–æ–¥–ø–∏—Å–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é:* `{ID}`', parse_mode="Markdown", reply_markup=back_markup)
                #–ö–ª–∞–≤–∞
                subscribe_markup = types.InlineKeyboardMarkup(row_width=1)
                admin_id_button = types.InlineKeyboardButton(f"–ê–¥–º–∏–Ω: {message.chat.id}", url=f'tg://openmessage?user_id={message.chat.id}')
                user_button = types.InlineKeyboardButton(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {ID}", url=f'tg://openmessage?user_id={ID}')
                subscribe_markup.add(admin_id_button, user_button)
                bot.send_message(bot_logs, f'‚ö°Ô∏è *–ê–¥–º–∏–Ω* `{message.chat.id}`* –æ–±–Ω–æ–≤–∏–ª –ø–æ–¥–ø–∏—Å–∫—É (–∞–Ω–Ω—É–ª–∏—Ä–æ–≤–∞–Ω–∞) –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é* `{ID}`', parse_mode="Markdown", reply_markup=subscribe_markup)
                connect.close()
            except:
                bot.send_message(message.chat.id, f'‚ö°Ô∏è *–û—à–∏–±–∫–∞!*', parse_mode="Markdown", reply_markup=back_markup)
                connect.close()

        def sendall1(message):
            connect = sqlite3.connect('users.db')
            cursor = connect.cursor()
            users = cursor.execute(f"SELECT user_id from users").fetchall()
            try:
                x = 0
                y = 0
                text = message.text
                bot.send_message(message.chat.id, f'‚ö°Ô∏è *–†–∞—Å—Å—ã–ª–∫–∞ –Ω–∞—á–∞–ª–∞—Å—å!*', parse_mode='Markdown')
                for user in users:
                    user = user[0]
                    try:
                        bot.send_message(user, f'{text}', parse_mode='Markdown', reply_markup=channel_markup)
                        x=x+1
                    except:
                        y=y+1
                bot.send_message(message.chat.id, f'‚ö°Ô∏è *–†–∞—Å—Å—ã–ª–∫–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!*\n\n*–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏:* {x}\n*–ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª–∏ –±–æ—Ç–∞:* {y}', parse_mode='Markdown', reply_markup=back_markup)
                connect.close()
            except:
                bot.send_message(f'{ID}', f'‚ö°Ô∏è *–û—à–∏–±–∫–∞!*', parse_mode="Markdown", reply_markup=back_markup)
                connect.close()

        bot.polling(none_stop=True)
    except:
        time.sleep(3)